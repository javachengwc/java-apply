----------------------------------mysql死锁-----------------------------------
死锁是数据库操作中，2+个事务因争夺资源而造成的相互等待的现象。
常见死锁情况及解决方案
1，事务之间对资源访问顺序的交替
A用户问A资源锁住A时请求B资源，B用户问B资源锁住B时请求A资源，产生死锁
解决方法：
多用户操作多表资源时，按照相同资源访问顺序进行处理。
2，并发修改同一记录
两个事务都对同一条记录做更改，都是先读取后修改。读取时加S锁，写入时加X锁，
一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，
因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。
第二个事务试图获取排它 (X) 锁以进行更新，由于两个事务都要转换为排它 (X) 锁，
并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。
解决方法：使用乐观锁或悲观锁进行控制

锁对应的死锁日志:
记录锁（LOCK_REC_NOT_GAP）         ------ lock_mode X locks rec but not gap
间隙锁（LOCK_GAP）                 ------ lock_mode X locks gap before rec
Next-key锁（LOCK_ORNIDARY）        ------ lock_mode X
插入意向锁（LOCK_INSERT_INTENTION）------ lock_mode X locks gap before rec insert intention

死锁排查处理过程：
    1,错误日志发现死锁异常
    2,查看 MySQL 死锁相关的日志
    3,根据 binlog 查看死锁相关事务的执行内容
    4,根据上述信息找出两个相互死锁的事务执行的 SQL 操作
    5,修改业务代码,修复死锁

show engine innodb status;                               ---查看最近死锁情况(如果发生过死锁)
set global innodb_print_all_deadlocks=ON;                ---开启死锁监控
show variables like 'innodb_deadlock_detect';            ---是否开启死锁检查，默认开启

------------------------------------------------------------------------------