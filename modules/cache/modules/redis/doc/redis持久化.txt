----------------------------------redis持久化------------------------------------
RDB---RDB持久指定时dump数据快照(point-in-time snapshot)到磁盘上,RDB是一种表示某个即时点的 Redis 数据的紧凑文件。
      RDB是Redis的默认持久化方式,默认存放路径是当前目录，文件名是:dump.rdb,RDB适合用于备份。
      RDB很容易的恢复不同版本的数据集以容灾,非常适合于灾难恢复。
      a,RDB持久化也分两种：SAVE和BGSAVE,默认是BGSAVE
          1,SAVE是阻塞式的RDB持久化，当执行这个命令时redis的主进程把内存里的数据库状态写入到RDB文件（即上面的dump.rdb）中，
          直到该文件创建完毕的这段时间内redis将不能处理任何命令请求。
          2,BGSAVE属于非阻塞式的持久化，它会创建一个子进程专门去把内存中的数据库状态写入RDB文件里，同时主进程还可以处理来自客户端的命令请求。
          但子进程基本是复制的父进程，这等于两个相同大小的redis进程在系统上运行，会造成内存使用率的大幅增加。
          比如说主进程8G内存，那么在备份的时候必须保证有16G内存，要不然会启用虚拟内存，性能非常差。
      b,如果数据集非常大并且 CPU 性能不够强大的话，fork()比较耗时,Redis 会停止服务客户端几毫秒甚至一秒。
      c,RDB文件过大时，是可以压缩的，Redis默认开启压缩，当然也可以通过配置rdbcompression参数来禁用压缩。
      d,手动快照:如果没有触发自动快照，可以对redis进行手动快照操作，SAVE和BGSAVE都可以执行手动快照，
          两个命令的区别是前者是由主进程进行快照操作，会阻塞其他请求；而后者是通过fork子进程进行快照操作。

      在redis.conf中的rdb配置
      dffilename  dump.rdb                ###rdb文件名
      dir  ./                             ###rdb文件存放路径
      rdbcompression  yes                 ###开启RDB文件压缩，默认开启压缩
      stop-writes-on-bgsave-error yes     ###后台备份进程出错时,主进程停不停止写入?  主进程不停止 容易造成数据不一致
      rdbchecksum yes                     ###导入rdb恢复时数据时,要不要检验rdb的完整性 验证版本是不是一致
      save 900 1                          ###15分钟内至少有1个键被改动则进行快照
      save 300 10                         ###5分钟内至少有10个键被改动则进行快照
      save 60  100                        ###1分钟类至少有100个键被改动则进行快照，以上条件是"或"的关系
      在命令行中操作配置:
      > CONFIG GET save                   ###查看redis持久化配置
      1) "save"
      2) "900 1 300 10 60 100"
      > CONFIG SET save "120 200"         ###修改redis持久化配置
      e,Redis的rdb文件备份,对于数据备份是非常友好的，可以在服务器运行的时候对 RDB文件进行复制:RDB 文件一旦被创建，就不会进行任何修改。
          当服务器要创建一个新的RDB文件时， 它先将文件的内容保存在一个临时文件里面，当临时文件写入完毕时，
          程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。
          对于Redis备份，建议创建一个定期任务（cron job），每小时将一个RDB文件备份到一个文件夹,并且每天将一个 RDB 文件备份到另一个文件夹。
          确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用find命令来删除过期的快照,
          至少每天一次，将RDB备份到运行Redis服务器的物理机器之外。
      f,Redis通过rdb备份文件的恢复
          将备份文件(dump.rdb)移动到 redis 安装目录并启动服务即可
      f,RDB文件手动合并
          RDB格式如下：头5个字节是字符REDIS。之后4个字节代表版本号,之后2个字节 FE 00，FE是标识 00是数据库,最后的结尾9个字节,FF 加上8个字节的CRC64校验码
          比如某redis集群中有8个rdb文件，每个500MB。现在需要把它合并成一个文件，在一个redis服务中导入
          1,生成对应的文件
              文件1 大小566346600，截取尾部的9个字节，dd bs=1 if=src_1.rdb of=1.rdb count=566346591
              文件2 大小570214520，跳过头部的11个字节，再截取尾部的9个字节 dd bs=1 if=src_2.rdb of=2.rdb skip=11 count=570214500
              ......
              文件8 大小569253070，跳过头部的11个字节，再截取尾部的8个字节，保留FF。 dd bs=1 if=src_8.rdb of=8.rdb skip=11 count=569253051
              合并文件 cat 1.rdb > dump.rdb,cat 2.rdb >> dump.rdb ...cat 8.rdb >> dump.rdb。到此备份文件合并完成
          2,检查备份文件,redis-check-rdb dump.rdb ,会提示没有crc校验
          3,修改配置文件 rdbchecksum no，因为数据库备份文件里面不包含crc64的校验码，配置文件中关闭选项
          4,重启redis
RDB缺点
          a,如果需要尽量避免在服务器故障时丢失数据，那么RDB不适合。虽然Redis允许设置不同的保存点（save point）来控制保存RDB文件的频率,\
            但是，因为RDB 文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。可能会至少5分钟才保存一次RDB文件。
            在这种情况下，一旦发生故障停机，就可能会丢失好几分钟的数据。
          b,每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。
            在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；
            如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。
            虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。
-----------------------------------------------------
AOF---AOF(append only file)持久化将reids的操作日志以追加的方式写入文件,将发送到redis服务端的每一条写命令都记录下来，并且保存到硬盘中的AOF文件中，
      类似打日志文件，来一条命令就记录一条。在服务器启动时，通过重新执行这些命令来还原数据集。
      a,AOF的持久化是通过命令追加、文件写入和文件同步三个步骤实现的。
          当reids开启AOF后，服务端每执行一次写操作（如set、sadd、rpush）就会把该条命令追加到一个单独的AOF缓冲区的末尾，这就是命令追加；
          然后把AOF缓冲区的内容写入AOF文件里。看上去第二步就已经完成AOF持久化了那第三步是干什么的呢?
          这就需要从系统的文件写入机制说起：一般现在所使用的操作系统，为了提高文件的写入效率，都会有一个写入策略，
          当往硬盘写入数据时，操作系统不是实时的将数据写入硬盘，而是先把数据暂时的保存在一个内存缓冲区里，
          等到这个内存缓冲区的空间被填满或者是超过了设定的时限后才会真正的把缓冲区内的数据写入硬盘中。
          也就是说当redis进行到第二步文件写入的时候，从用户的角度看是已经把AOF缓冲区里的数据写入到AOF文件了，
          但对系统而言只不过是把AOF缓冲区的内容放到了另一个内存缓冲区里而已，
          之后redis还需要进行文件同步把该内存缓冲区里的数据真正写入硬盘上才算是完成了一次持久化。
          而何时进行文件同步则是根据配置的appendfsync来进行： appendfsync有三个选项：always、everysec和no：
              1,选择always的时候服务器会在每执行一个事件就把AOF缓冲区的内容强制性的写入硬盘上的AOF文件里，
                  可以看成每执行一个redis写入命令就往AOF文件里记录这条命令，这保证了数据持久化的完整性，但效率是最慢的，却也是最安全的；
              2,配置成everysec的话服务端每执行一次写操作（如set、sadd、rpush）也会把该条命令追加到一个单独的AOF缓冲区的末尾，并将AOF缓冲区写入AOF文件，
                  然后每隔一秒才会进行一次文件同步把内存缓冲区里的AOF缓存数据真正写入AOF文件里，
                  这个模式兼顾了效率的同时也保证了数据的完整性，即使在服务器宕机也只会丢失一秒内对redis数据库做的修改；
              3,将appendfsync配置成no则意味redis数据库里的数据就算丢失也可以接受，它也会把每条写命令追加到AOF缓冲区的末尾，然后写入文件，
                  但什么时候进行文件同步真正把数据写入AOF文件里则由系统自身决定，即当内存缓冲区的空间被填满或者是超过了设定的时限后系统自动同步。
                  这种模式下效率是最快的，但对数据来说也是最不安全的，
                  如果redis里的数据都是从后台数据库如mysql中取出来的，属于随时可以找回或者不重要的数据，那么可以考虑设置成这种模式。
      b,AOF文件的位置和RDB文件的位置相同，都是通过dir参数设置，默认的文件名是appendonly.aof，可以通过appendfilename参数来修改。
      c,AOF文件重写可以去除数据的中间执行过程，直接保留最终数据命令。
        相比RDB每次持久化都会内存翻倍，AOF持久化除了在第一次启用时会新开一个子进程创建AOF文件会大幅度消耗内存外，之后的每次持久化对内存使用都很小。
        但AOF也有一个不可忽视的问题：AOF文件过大。对redis数据库的每一次写操作都会让AOF文件里增加一条数据，久而久之这个文件会很大。
        redis提出了AOF重写的机制，它创建一个精简化的AOF文件，里面去掉了多余的冗余命令，并对原AOF文件进行覆盖。
          如果不进行AOF重写的话，进行AOF文件恢复的时候，Redis会执行AOF文件中的每一条命令
          进行AOF重写后，相当于把中间的计算过程略去。直接把计算得到的结果设置进redis，相当于每个key仅执行了一条命令。使用BGREWRITEAOF命令来重写AOF文件。
          重写策略的参数设置:
          auto-aof-rewrite-percentage 100
          ###当前的AOF文件大小超过上一次重写后的AOF文件大小的百分之多少时，会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。
          auto-aof-rewrite-min-size 64mb
          ###限制了允许重写的最小AOF文件大小，通常在AOF文件很小的时候，即使其中有些冗余的命令也是可以忽略的。
        AOF 重写的执行步骤：
            Redis执行fork(),现在同时拥有父进程和子进程。
            子进程开始将新AOF文件的内容写入到临时文件。
            对于所有新执行的写入命令父进程一边将它们累积到一个内存缓存中一边将这些改动追加到现有AOF文件的末尾:这样即使在重写的中途发生停机,现有的AOF文件也还是安全的。
            当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
            现在Redis原子地用新文件替换旧文件,之后所有命令都会直接追加到新AOF文件的末尾。
      d,AOF Redis 会更具有可持久性(durable)：可以有很多不同的 fsync 策略：没有 fsync，每秒 fsync，每次请求时 fsync。
          使用默认的每秒 fsync 策略，写性能也仍然很不错(fsync 是由后台线程完成的，主线程继续努力地执行写请求)，只是宕机时有可能会损失一秒钟的写数据。
      e,AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。
          即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof 工具也可以很轻易的修复。redis-check-aof --fix
      f,AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。即使不小心错误地使用 FLUSHALL 命令清空一切，如果此时并没有执行重写，
          仍然可以恢复保存的数据集，只要停止服务器，删除AOF文件末尾的 FLUSHALL 命令，然后重启 Redis 即可。
      在redis.conf中的aof配置
            appendonly yes                       ###开启AOF持久化，默认关闭
            dir  ./                              ###aop文件存放路径,其实跟rdb是一样的目录
            appendfilename "appendonly.aof"      ###AOF文件名称（默认）
            appendfsync everysec                 ###AOF持久化策略,有3种,always、everysec和no
            auto-aof-rewrite-percentage 100      ###触发AOF文件重写机制的重写的条件（默认）
            auto-aof-rewrite-min-size 64mb       ###触发AOF文件重写机制的重写的条件（默认）
            no-appendfsync-on-rewrite no         ###在AOF日志进行重写BGREWRITEAOF时，如果设置为yes表示新写操作不进行同步fsync，
                                                     只是暂存在缓冲区里，避免造成磁盘IO操作冲突，等重写完成后在写入。redis中默认为no
            aof-load-truncated yes               ###Redis再恢复时，忽略最后一条可能存在问题的指令(因为最后一条指令可能存在问题，比如写一半时突然断电了)
            aof-use-rdb-preamble no              ###Redis4.0新增RDB-AOF混合持久化格式，在开启了这个功能之后，AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，
                                                     其中RDB格式的内容用于记录已有的数据，而AOF格式的内存则用于记录最近发生了变化的数据，
                                                     这样Redis就可以同时兼有RDB持久化和AOF持久化的优点（既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据）。
      bgrewriteaof                               ###执行aof日志的rewrite
------------------------------------
RDB与AOF对比
    a,RDB在重启保存了大数据集的实例时比 AOF 要快,因为RDB是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行。
    b,对同样的数据集，AOF 文件通常要大于等价的 RDB 文件。
Redis可以同时使用 AOF 持久化和 RDB 持久化。在这种情况下，当 Redis 重启时，它会优先使用 AOF 文件来还原数据集，因为 AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。
在Redis2.2 或以上版本，可以在不重启的情况下，从RDB切换到AOF
    a,为最新的 dump.rdb 文件创建一个备份。
    b,执行以下两条命令：
        redis-cli> CONFIG SET appendonly yes    ###启动AOF功能,redis阻塞直到初始AOF文件创建完成为止,之后Redis会继续处理命令请求，并开始将写入命令追加到 AOF 文件末尾。
                                                   别忘了在redis.conf中打开AOF功能,否则服务器启之后，之前通过CONFIG SET设置的配置就会失效，程序会按原来的配置来启动服务。
        redis-cli> CONFIG SET save ""           ###关闭RDB功能, 这一步是可选的,也可以同时使用 RDB 和 AOF 这两种持久化功能
    c,确保命令执行之后，数据库的键的数量没有改变。
    d,确保写命令会被正确地追加到 AOF 文件的末尾。
在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。
反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。

通常来说，应该同时使用这两种持久化方法，以达到和 PostgreSQL 提供的一样的数据安全程度。

---------------------------------------------------------------------------------