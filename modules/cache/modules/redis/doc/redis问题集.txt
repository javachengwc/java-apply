1,set值时报错JedisDataException: ERR unknown command 'PSETEX'
版本兼容问题，Redis Psetex 命令以毫秒为单位设置 key 的生存时间，可用版本 >= 2.6.0。

2,缓存穿透，缓存击穿，缓存雪崩
缓存穿透：缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，
         如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
         解决方案：
         接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
         从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点。
         这样可以防止攻击用户反复用同一个id暴力攻击
缓存击穿：缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，
         又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
         解决方案：
         a,设置热点数据永远不过期。
         b,接口限流与熔断，降级。
         c,加互斥锁。
缓存雪崩：缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。
         和缓存击穿不同，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
         解决方案：
         缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
         如果缓存是分布式部署，将热点数据均匀分布在不同缓存节点中。
         设置热点数据永远不过期。

3，缓存和数据库数据的一致性
缓存和DB 的一致性，指的更多的是最终一致性。使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。
结论：先淘汰缓存，再写数据库。
缓存架构设计：
1.更新缓存 VS 淘汰缓存
更新缓存：数据不但写入数据库，还会写入缓存；优点：缓存不会增加一次miss，命中率高
淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉；优点：简单
淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，
2.先操作数据库 vs 先操作缓存
当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：
（1）先写数据库，再淘汰缓存
（2）先淘汰缓存，再写数据库
对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，
解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。
由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。
假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。
假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。
结论：数据和缓存的操作时序：先淘汰缓存，再写数据库。
