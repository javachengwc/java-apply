-----------------------------redis集群-------------------------
redis在3.0版本以后增加了集群特性，比以前的主从复制有了质的提升。
redis cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。
Redis集群中，节点负责存储数据、记录集群的状态（包括键值到正确节点的映射）。
集群节点同样能自动发现其他节点，检测出没正常工作的节点， 并且在需要的时候在从节点中推选出主节点。
一个主节点要被故障转移，必须是大多数主节点在至少 NODE_TIMEOUT 这么长时间里无法访问该节点。
其结构特点：
    1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
    2、节点的fail是通过集群中超过半数的节点检测失效时才生效。
    3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
    4、Redis集群没有使用一致性hash, 而是引入了哈希槽的概念。
       Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽
redis cluster节点分配
    三个主节点A, B, C,采用哈希槽 (hash slot)的方式来分配16384个slot，它们三个节点分别承担的slot 区间是：
    节点A覆盖0－5460;节点B覆盖5461－10922;节点C覆盖10923－16383.
    如果存入一个值，按照redis cluster哈希槽的算法： CRC16('key')%16384 = 6782。 那么就会把这个key 的存储分配到 B 上了。
    同样，当连接(A,B,C)任何一个节点想获取'key'这个key时，也会这样的算法，然后内部跳转到B节点上获取数据
    新增一个节点D，redis cluster从各个节点的前面各拿取一部分slot到D上，大致就会变成这样：
    节点A覆盖1365-5460,节点B覆盖6827-10922,节点C覆盖12288-16383,节点D覆盖0-1364,5461-6826,10923-12287
    同样删除一个节点也是类似，移动完成后就可以删除这个节点了。
redis cluster在线重新分片
    Redis 集群支持在集群运行过程中添加或移除节点。实际上，添加或移除节点都被抽象为同一个操作，那就是把哈希槽从一个节点移到另一个节点。
        向集群添加一个新节点，就是把一个空节点加入到集群中并把某些哈希槽从已存在的节点移到新节点上。
        从集群中移除一个节点，就是把该节点上的哈希槽移到其他已存在的节点上。所以实现这个的核心是能把哈希槽移来移去。
        从实际角度看，哈希槽就只是一堆键，所以 Redis 集群在重组碎片（reshard）时做的就是把键从一个节点移到另一个节点。
    Redis cluster的一些命令，用来操作 Redis 集群节点上的哈希槽转换表（slots translation table）
        CLUSTER ADDSLOTS slot1 [slot2] … [slotN]
        CLUSTER DELSLOTS slot1 [slot2] … [slotN]
        CLUSTER SETSLOT slot NODE node
        CLUSTER SETSLOT slot MIGRATING node
        CLUSTER SETSLOT slot IMPORTING node
    ADDSLOTS 和 DELSLOTS，就是简单地用来给一个 Redis 节点指派（assign）或移除哈希槽。
redis cluster高可用
    为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，
    当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。
    比如集群有A,B,C三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，就无法访问整个集群了。A和C的slot也无法访问。
    所以在集群建立的时候，一定要为每个主节点都添加了从节点,
    比如集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。
    B1节点替代了B节点，Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。
    如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。
redis cluster中的节点
    Redis集群中的节点有以下责任:
        持有键值对数据。
        记录集群的状态，包括键到正确节点的映射（mapping keys to right nodes）。
        自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。
    为了执行以上列出的任务， 集群中的每个节点都与其他节点建立起了“集群连接（cluster bus）”， 该连接是一个 TCP 连接， 使用二进制协议进行通讯。
    节点之间使用 Gossip 协议 来进行以下工作：
        传播（propagate）关于集群的信息，以此来发现新的节点。
        向其他节点发送 PING 数据包，以此来检查目标节点是否正常运作。
        在特定事件发生时，发送集群信息。
    除此之外， 集群连接还用于在集群中发布或订阅信息。
    每个节点在集群中都有一个独一无二的 ID ， 该 ID 是一个十六进制表示的 160 位随机数， 在节点第一次启动时由 /dev/urandom 生成。
    节点会将它的 ID 保存到配置文件， 只要这个配置文件不被删除， 节点就会一直沿用这个 ID 。
    节点 ID 用于标识集群中的每个节点。 一个节点可以改变它的 IP 和端口号， 而不改变节点 ID 。
    集群可以自动识别出 IP/端口号的变化， 并将这一信息通过 Gossip 协议广播给其他节点知道。
    以下是每个节点都有的关联信息， 并且节点会将这些信息发送给其他节点：
        节点所使用的 IP 地址和 TCP 端口号。
        节点的标志（flags）。
        节点负责处理的哈希槽。
        节点最近一次使用集群连接发送 PING 数据包（packet）的时间。
        节点最近一次在回复中接收到 PONG 数据包的时间。
        集群将该节点标记为下线的时间。
        该节点的从节点数量。
        如果该节点是从节点的话，那么它会记录主节点的节点 ID 。 如果这是一个主节点的话，那么主节点 ID 这一栏的值为 0000000 。
    以上信息的其中一部分可以通过向集群中的任意节点（主节点或者从节点都可以）发送 CLUSTER NODES 命令来获得。
    因为集群节点不能代理（proxy）命令请求， 所以访问节点的客户端应该在节点返回 -MOVED 或者 -ASK 转向（redirection）错误时， 自行将命令请求转发至其他节点。
    因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点，
    所以在理论上来说， 客户端是无须保存集群状态信息的。
    不过， 如果客户端可以将键和节点之间的映射信息保存起来， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。
MOVED 转向
    一个 Redis 客户端可以向集群中的任意节点（包括从节点）发送命令请求。
    节点会对命令请求进行分析， 如果该命令是集群可以执行的命令， 那么节点会查找这个命令所要处理的键所在的槽。
    如果要查找的哈希槽正好就由接收到命令的节点负责处理， 那么节点就直接执行这个命令。
    如果所查找的槽不是由该节点处理的话， 节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录， 并向客户端回复一个 MOVED 错误。
    以下是一个 MOVED 错误的例子：
        GET x
        -MOVED 3999 127.0.0.1:6381
    错误信息包含键 x 所属的哈希槽 3999 ， 以及负责处理这个槽的节点的 IP 和端口号 127.0.0.1:6381 。
    客户端需要根据这个 IP 和端口号， 向所属的节点重新发送一次 GET 命令请求。
    注意， 即使客户端在重新发送 GET 命令之前， 等待了非常久的时间， 以至于集群又再次更改了配置， 使得节点 127.0.0.1:6381 已经不再处理槽 3999 ，
    那么当客户端向节点 127.0.0.1:6381 发送 GET 命令的时候， 节点将再次向客户端返回 MOVED 错误， 指示现在负责处理槽 3999 的节点。
    虽然用 ID 来标识集群中的节点， 但是为了让客户端的转向操作尽可能地简单， 节点在 MOVED 错误中直接返回目标节点的 IP 和端口号， 而不是目标节点的 ID 。
    虽然不是必须的， 但一个客户端应该记录（memorize）下“槽 3999 由节点 127.0.0.1:6381 负责处理“这一信息，
    这样当再次有命令需要对槽 3999 执行时， 客户端就可以加快寻找正确节点的速度。
    注意， 当集群处于稳定状态时， 所有客户端最终都会保存有一个哈希槽至节点的映射记录（map of hash slots to nodes），
    使得集群非常高效： 客户端可以直接向正确的节点发送命令请求， 无须转向、代理或者其他任何可能发生单点故障（single point failure）的实体（entiy）。
ASK 转向
    当节点需要让一个客户端长期地（permanently）将针对某个槽的命令请求发送至另一个节点时， 节点向客户端返回 MOVED 转向。
    另一方面， 当节点需要让客户端仅仅在下一个命令请求中转向至另一个节点时， 节点向客户端返回 ASK 转向。
    比如说，槽 8 所包含的各个键分散在节点 A 和节点 B 中， 所以当客户端在节点 A 中没找到某个键时， 它应该转向到节点 B 中去寻找，
    但是这种转向应该仅仅影响一次命令查询， 而不是让客户端每次都直接去查找节点 B ： 在节点 A 所持有的属于槽 8 的键没有全部被迁移到节点 B 之前，
    客户端应该先访问节点 A ， 然后再访问节点 B 。
    因为这种转向只针对 16384 个槽中的其中一个槽， 所以转向对集群造成的性能损耗属于可接受的范围。
    因为上述原因， 如果需要在查找节点 A 之后， 继续查找节点 B ， 那么客户端在向节点 B 发送命令请求之前，
    应该先发送一个 ASKING 命令， 否则这个针对带有 IMPORTING 状态的槽的命令请求将被节点 B 拒绝执行。
    接收到客户端 ASKING 命令的节点将为客户端设置一个一次性的标志（flag）， 使得客户端可以执行一次针对 IMPORTING 状态的槽的命令请求。
    从客户端的角度来看， ASK 转向的完整语义（semantics）如下：
        如果客户端接收到 ASK 转向， 那么将命令请求的发送对象调整为转向所指定的节点。
        先发送一个 ASKING 命令，然后再发送真正的命令请求。
        不必更新客户端所记录的槽 8 至节点的映射： 槽 8 应该仍然映射到节点 A ， 而不是节点 B 。
    一旦节点 A 针对槽 8 的迁移工作完成， 节点 A 再次收到针对槽 8 的命令请求时， 就会向客户端返回 MOVED 转向， 将关于槽 8 的命令请求长期地转向到节点 B 。
    注意， 即使客户端出现 Bug ， 过早地将槽 8 映射到了节点 B 上面， 但只要这个客户端不发送 ASKING 命令， 客户端发送命令请求的时候就会遇上 MOVED 错误， 并将它转向回节点 A 。
从节点的选举和提升
    一个从节点的选举是在它的主节点被至少一个具有成为主节点必备条件的从节点标记为 FAIL 的状态的时候发生的。
    当以下条件满足时，一个从节点可以发起选举：
        该从节点的主节点处于 FAIL 状态。
        这个主节点负责的哈希槽数目不为零。
        从节点和主节点之间的重复连接（replication link）断线不超过一段给定的时间，这是为了确保从节点的数据是可靠的。
    一个从节点想要被推选出来，那么第一步应该是提高它的 currentEpoch 计数，并且向集群中的所有主节点们请求投票。
    从节点通过广播一个 FAILOVER_AUTH_REQUEST 数据包给集群里的每个主节点来请求选票。然后等待回复（最多等 NODE_TIMEOUT 这么长时间）。
    投票遵循先到先得的规则，集群主节点会投票给第一个发送选举信息的该从节点，返回一条FAILOVER_AUTH_ACK消息。
    一旦一个主节点给这个从节点投票，回复一个 FAILOVER_AUTH_ACK，并且在 NODE_TIMEOUT * 2 这段时间内不能再给同个主节点的其他从节点投票。
    在这段时间内它完全不能回复其他授权请求。
    从节点会忽视所有带有的时期（epoch）参数比 currentEpoch 小的回应（ACKs），这样能避免把之前的投票的算为当前的合理投票。
    一旦某个从节点收到了大多数主节点的回应，如果集群主节点的个数是N，当某个从节点收到大于等于N / 2 + 1张支持票时，它就赢得了选举。
    否则，如果无法在 NODE_TIMEOUT 时间内访问到大多数主节点，
    那么当前选举会被中断并在 NODE_TIMEOUT * 4 这段时间后由另一个从节点尝试发起选举。
    从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一点点延迟，这段延迟是这么计算的：
    DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +SLAVE_RANK * 1000 milliseconds.
    固定延时（fixed delay）确保我等到 FAIL 状态在集群内广播后，否则若从节点尝试发起选举，主节点们仍然不知道那个主节点已经 FAIL，就会拒绝投票。
    随机延时（random delay）是用来添加一些不确定因素以减少多个从节点在同一时间发起选举的可能性，
    因为若同时多个从节点发起选举或许会导致没有任何节点赢得选举，要再次发起另一个选举的话会使集群在当时变得不可用。
    一旦有从节点赢得选举，它就会开始用 ping 和 pong 数据包向其他节点宣布自己已经是主节点，并提供它负责的哈希槽，
    设置 configEpoch 为 currentEpoch（选举开始时生成的）。
    为了加速其他节点的重新配置，该节点会广播一个 pong 包 给集群里的所有节点（那些现在访问不到的节点最终也会收到一个 ping 包或 pong 包，并且进行重新配置）。
    其他节点会检测到有一个新的主节点（带着更大的configEpoch）在负责处理之前一个旧的主节点负责的哈希槽，然后就升级自己的配置信息。
备份迁移
    Redis 集群实现了一个叫做备份迁移（replica migration）的概念，以提高系统的可用性。
    例如有一个每个主节点都只有一个从节点的集群，当主节点或者从节点故障失效的时候集群能让操作继续执行下去，但如果主从节点都失效的话就没法让操作继续执行下去。
    主节点 A 有且只有一个从节点 A1。主节点 A 失效了。A1 被提升为新的主节点。之后，A1 因为一个独立事件（跟节点 A 的失效无关）失效了。
    由于没有其他从节点可以提升为主节点（因为节点 A 仍未恢复正常），集群没法继续进行正常操作。
    一个候选方案就是在集群中创建不对称性，然后让集群布局时不时地自动变化。
    例如，假设集群有三个主节点 A，B，C。节点 A 和 B 都各有一个从节点，A1 和 B1。节点 C 有两个从节点：C1 和 C2。
    备份迁移是从节点自动重构的过程，为了迁移到一个没有可工作从节点的主节点上。在上面提到的例子中，备份迁移过程如下：
        主节点 A 失效。A1 被提升为主节点。
        节点 C2 迁移成为节点 A1 的从节点，要不然 A1 就没有任何从节点。
        三个小时后节点 A1 也失效了。
        节点 C2 被提升为取代 A1 的新主节点。
        集群仍然能继续正常工作。
备份迁移算法
    迁移算法不用任何形式的协议，因为 Redis 集群中的从节点布局不是集群配置信息（配置信息要求前后一致并且/或者用 config epochs 来标记版本号）的一部分。
    它使用的是一个避免在主节点没有备份时从节点大批迁移的算法。这个算法保证，一旦集群配置信息稳定下来，最终每个主节点都至少会有一个从节点作为备份。
    一个好的从节点是指从给定节点的角度看，该从节点不处于 FAIL 状态。
    每个从节点若检测出存在至少一个没有好的从节点的单一主节点，那么就会触发这个算法的执行。然而在所有检测出这种情况的从节点中，只有一部分从节点会采取行动。
    通常这“一部分从节点”都只有一个，除非有不同的从节点在给定时间间隔里对其他节点的失效状态有稍微不同的视角。
    采取行动的从节点是属于那些拥有最多从节点的主节点，并且不处于 FAIL 状态及拥有最小的节点 ID。
    例如，如果有 10 个主节点，它们各有 1 个从节点，另外还有 2 个主节点，它们各有 5 个从节点。
    会尝试迁移的从节点是在那 2 个拥有 5 个从节点的主节点中的所有从节点里，节点 ID 最小的那个。
    已知不需要用到任何协议，在集群配置信息不稳定的情况下，有可能发生一种竞争情况：多个从节点都认为自己是不处于 FAIL 状态并且拥有较小节点 ID（实际上这是一种比较难出现的状况）。
    如果这种情况发生的话，结果是多个从节点都会迁移到同个主节点下，不过这种结局是无害的。
    这种竞争发生的话，有时候会使得割让出从节点的主节点变成没有任何备份节点，
    当集群再次达到稳定状态的时候，本算法会再次执行，然后把从节点迁移回它原来的主节点。
    最终每个主节点都会至少有一个从节点作为备份节点。
    这个算法能通过一个用户可配置的参数 cluster-migration-barrier 进行控制。
    这个参数表示的是，一个主节点在拥有多少个好的从节点的时候就要割让一个从节点出来。
    例如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。
redis cluster集群注意事项
    Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.
    Redis集群不像单Redis那样支持多个数据库，集群只有数据库 0，而且也不支持SELECT命令
    Redis集群并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作.原因是因为集群是用了异步复制. 写操作过程:
        客户端向主节点B写入一条命令.
        主节点B向客户端回复命令状态.
        主节点将写操作复制给它的从节点 B1, B2 和 B3.
    主节点对命令的复制工作发生在返回命令回复之后。复制有可能在主节点出问题的时候而失败，而从节点还没来得及得到之前的命令就转换成主节点了，从而丢失上一条命令

---------------------------------------------------------------