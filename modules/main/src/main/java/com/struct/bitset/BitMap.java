package com.struct.bitset;

/**
 * 位图bitmap在很多海量数据处理的情况下会用到。一些典型的情况包括数据过滤，数据位设置和统计等。
 * 它的引入和应用通常是考虑到海量数据的情况下，用普通的数组会超出数据保存的范围。
 * 使用这种位图的方式虽然不能在根本上解决海量数据处理的问题，但是在一定的数据范围内，它是一种有效的方法。
 * 这里的实现是搜索引擎lucene的代码片段，在java的类库里有一个对应的实现：BitSet。
 * bitmap本质上也是一个数组，只是用数组中间对应的位来表示一个对应的数字。
 * 假设用byte数组，数字1则对应数组第1个元素的第一位。数字9则超出了第一个元素的8位范围，它对应第二个元素的第一位。
 * 这样依次类推，就可以把海量数据映射到这个byte数组里。
 * bitmap主要的功能包括有一下几个方面。
 *     1. 设置位(set)：将某一位设置为1.
 *     2. 清除位(clear)，将某一位设置为0.
 *     3. 读取位(get)，读取某一位的数据，看结果是1还是0.
 *     4. 容器所能容纳的位个数（size），相当于返回容器的长度。
 *     5. 被置位的元素个数（count），返回所有被置为1的位的个数。
 */
public class BitMap {

    // BYTE_COUNTS的数组，记录了对应一个数字1的个数。
    // 在bit[i] && 0xff运算之后得到的是一个8位的数字，范围从0到255.那么，问题就归结到找到对应数字的二进制表示里1的个数。
    // 比如说数字0有0个1， 1有1个1， 2有1个1，3有2个1...。在一个byte里面，最多有256种，
    // 这里就是将这256个数字对应的1个数都事先编码保存，后面求这个数字对应的1个数直接取就可以了
    private static final byte[] BYTE_COUNTS = {
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };

    private byte[] bits;

    private int size;

    //n表示有多少个数字
    public BitMap(int n) {
        this.size = n;
        this.bits = new byte[(size >> 3) + 1];
    }

    public boolean get(int data) {
        return (bits[data >> 3] & (1 << (data & 7))) != 0;
    }

    public void set(int data) {
        bits[data >> 3] |= 1 << (data & 7);
    }

    public void clear(int data) {
        bits[data >> 3] &= ~(1 << (data & 7));
    }

    public final int count() {
        int count=0;
        int end = bits.length;
        for (int i = 0; i < end; i++)
            count += BYTE_COUNTS[bits[i] & 0xFF];
        return count;
    }

}
