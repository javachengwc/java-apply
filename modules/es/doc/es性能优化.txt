---------------------------------------es性能优化--------------------------------
1，优化首选项--filesystem cache
os cache，操作系统的缓存，往es里写的数据，实际上都写到磁盘文件里去了，磁盘文件里的数据操作系统会自动将里面的数据缓存到os cache中。
es搜索依赖于底层的filesystem cache，如果给filesystem cache更多的内存，尽量让内存可以容纳所有的index segment file索引数据文件，那么搜索时基本是走内存，性能会非常高。
比如，3节点es集群，每节点内存64G，总内存，64 * 3 = 192g，每几点给es jvm heap 32G，那么剩下留给filesystem cache的就是32g，集群总共filesystem cache就是32 * 3 = 96g。
如果索引数据文件，在3节点上一共占用了1T的磁盘容量，es数据量是1t，每节点大概300g，但集群总的filesystem cache的内存不到100g，1/10的数据可以放内存，其他的都在磁盘，
执行搜索操作，大部分操作都是走磁盘，性能比较差。所以要让es性能好，最佳的情况下，就是机器的内存，至少可以容纳总数据量的一半。
在es中就存少量的数据，就是用来搜索的那些索引，尽量在es里，就存储必须用来搜索的数据,内存留给filesystem cache，这样可以更好满足数据几乎全部走内存来搜索。

2，数据预热
热搜索的数据可以提前每隔一段时间，提前访问进行搜索一次，刷到filesystem cache里去，后面实际搜索查看这些热数据，就可直接从内存里搜索了。

3，冷热分离
es可以做类似于mysql的水平拆分，将大量的访问很少，频率很低的数据，写一个索引，将访问很频繁的热数据单独写一个索引。
这样可以确保热数据在被预热之后，尽量都让他们留在filesystem os cache里，别让冷数据给冲刷掉。

4，document模型设计
es里面的复杂的关联查询，复杂的查询语法，一般性能都不太好，所以对es索引结构的设计，在一开始就设计好。
写入es的数据就已经是组装关联好的数据，搜索时，不需要利用es的搜索语法去完成类似join之类的搜索。
对于es的复杂查询操作，比如join，nested，parent-child搜索尽量避免，性能比较差。
尽量避免使用nested或 parent/child，能不用就不用；nested query慢， parent/child query 更慢，比nested query慢上百倍；
因此能在mapping设计阶段搞定的（大宽表设计或采用比较smart的数据结构），就不要用父子关系的mapping。
避免使用动态值作字段(key),  动态递增的mapping，会导致集群崩溃；同样，也需要控制字段的数量，业务中不使用的字段，就不要索引。

5,避免使用es分页查询，改用scroll api滚动查询
es的分页是会把每个shard上存储的前pageSize*pageNo条数据都查到一个协调节点上，协调节点对这些数据进行一些合并、处理，再获取到最终页数据。
就是分布式的分页查询,在往后翻页查询中，翻的越深，每个shard返回的数据越多，协调节点处理的时间越长。越翻到后面越是慢。
所以索引尽量避免深度分页,使用scroll api来进行获取翻页数据。scroll会一次性生成所有数据的一个快照，然后每次翻页就是通过游标移动，性能比分页高很多。
唯一缺点是，只能一页一页往后翻，不能随意跳到任何页。同时这个scroll是保留一段时间内的数据快照，有一定的时效性。

---------------------------------------------------------------------------------