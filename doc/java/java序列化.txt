----------------------------------java序列化-----------------------------------
数据序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等起着至关重要的作用，是提升分布式系统性能的最关键因素之一。

java中的序列化有很多，比如:
java自身序列化，实现Serializable接口。
json序列化
hession2序列化，dubbo RPC默认采用hessian2序列化
Kryo,一个针对Java语言的成熟的序列化实现，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的体积。
     已经在多个著名开源项目（如Hive、Storm）中广泛的使用。
     如果被序列化的类中不包含无参的构造函数，则在Kryo的序列化中，性能将会大打折扣，
     因为此时在底层将用Java的序列化来透明的取代Kryo序列化。所以，尽可能为每一个被序列化的类添加无参构造函数是一种最佳实践
    （一个java类如果不自定义构造函数，默认就有无参构造函数）。
FST
thrift序列化，是一个跨语言的序列化

网上给出的几种序列化对比
a,生成字节大小比较,序列化生成字节码的大小决定了远程调用的网络传输时间和带宽占用。
序列化 	             请求字节数 	           响应字节数
Kryo 	             272 	                   90
FST 	             288 	                   96
Dubbo Serialization  430 	                   186
Hessian 	         546 	                   329
FastJson 	         461 	                   218
Json 	             657 	                   409
Java Serialization 	 963 	                   630

b,序列化响应时间和吞吐量对比
远程调用方式 	                    平均响应时间 	          平均TPS（每秒事务数）
REST: Jetty + JSON 	                 7.806 	                  1280
REST: Tomcat + JSON 	             2.082 	                  4796
REST: Netty + JSON 	                 2.182 	                  4576
Dubbo: FST 	                         1.211 	                  8244
Dubbo: kyro 	                     1.182 	                  8444
Dubbo: dubbo serialization 	         1.43 	                  6982
Dubbo: hessian2 	                 1.49 	                  6701
Dubbo: fastjson 	                 1.572 	                  6352

可以看到不管从生成字节的大小，还是平均响应时间和平均TPS，Kryo和FST相比其他序列化方式都有非常显著的改进。
-------------------------------------------------------------------------------